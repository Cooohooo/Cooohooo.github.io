<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>高频前端面试题-基础篇 | Cary</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="专注于记录一些从开始到入门踩过的坑">
    <link rel="preload" href="/assets/css/0.styles.b8e99327.css" as="style"><link rel="preload" href="/assets/js/app.b1624e8e.js" as="script"><link rel="preload" href="/assets/js/2.12e8692c.js" as="script"><link rel="preload" href="/assets/js/30.ff71561f.js" as="script"><link rel="prefetch" href="/assets/js/10.eff93b86.js"><link rel="prefetch" href="/assets/js/11.793fbf77.js"><link rel="prefetch" href="/assets/js/12.4a71ec38.js"><link rel="prefetch" href="/assets/js/13.093a470d.js"><link rel="prefetch" href="/assets/js/14.c529c00a.js"><link rel="prefetch" href="/assets/js/15.9cc56e10.js"><link rel="prefetch" href="/assets/js/16.f161731c.js"><link rel="prefetch" href="/assets/js/17.438c44df.js"><link rel="prefetch" href="/assets/js/18.c02afc3a.js"><link rel="prefetch" href="/assets/js/19.c4b19fba.js"><link rel="prefetch" href="/assets/js/20.dec86c76.js"><link rel="prefetch" href="/assets/js/21.1b6d07c1.js"><link rel="prefetch" href="/assets/js/22.44c5118e.js"><link rel="prefetch" href="/assets/js/23.4da8ff8e.js"><link rel="prefetch" href="/assets/js/24.fdc9730d.js"><link rel="prefetch" href="/assets/js/25.806070ea.js"><link rel="prefetch" href="/assets/js/26.d8d44464.js"><link rel="prefetch" href="/assets/js/27.03a5f16f.js"><link rel="prefetch" href="/assets/js/28.e9711547.js"><link rel="prefetch" href="/assets/js/29.c20512e0.js"><link rel="prefetch" href="/assets/js/3.964ad172.js"><link rel="prefetch" href="/assets/js/31.44701f47.js"><link rel="prefetch" href="/assets/js/32.060499f3.js"><link rel="prefetch" href="/assets/js/33.c8f8e25c.js"><link rel="prefetch" href="/assets/js/34.484e7f5b.js"><link rel="prefetch" href="/assets/js/35.d0e86e52.js"><link rel="prefetch" href="/assets/js/36.6e9c597a.js"><link rel="prefetch" href="/assets/js/37.d0ea72cc.js"><link rel="prefetch" href="/assets/js/38.635da6e1.js"><link rel="prefetch" href="/assets/js/39.c6c12926.js"><link rel="prefetch" href="/assets/js/4.9e3305df.js"><link rel="prefetch" href="/assets/js/40.77988a3a.js"><link rel="prefetch" href="/assets/js/41.09ced7b0.js"><link rel="prefetch" href="/assets/js/42.f0c83ede.js"><link rel="prefetch" href="/assets/js/43.8433eb78.js"><link rel="prefetch" href="/assets/js/44.9a1d5c63.js"><link rel="prefetch" href="/assets/js/45.cb79a166.js"><link rel="prefetch" href="/assets/js/5.536117a3.js"><link rel="prefetch" href="/assets/js/6.fdeca71c.js"><link rel="prefetch" href="/assets/js/7.b91670df.js"><link rel="prefetch" href="/assets/js/8.53ae3032.js"><link rel="prefetch" href="/assets/js/9.2475cef8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8e99327.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Cary</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>高频前端面试题-基础篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interviewquestions/#html篇" class="sidebar-link">HTML篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#meta-viewport-是做什么用的" class="sidebar-link">meta viewport 是做什么用的?</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#content-type-有哪些？" class="sidebar-link">content-type 有哪些？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#dom-的重绘-和-回流" class="sidebar-link">DOM 的重绘 和 回流</a></li></ul></li><li><a href="/interviewquestions/#css篇" class="sidebar-link">CSS篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#说说盒模型" class="sidebar-link">说说盒模型</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#如何解决外边距叠加的问题？" class="sidebar-link">如何解决外边距叠加的问题？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#为什么padding-bottom-是基于父元素的宽度而不是父元素的高度计算的？" class="sidebar-link">为什么padding-bottom 是基于父元素的宽度而不是父元素的高度计算的？</a></li></ul></li><li><a href="/interviewquestions/#javascript篇" class="sidebar-link">JavaScript篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#javascript是什么，它的优缺点是什么？" class="sidebar-link">JavaScript是什么，它的优缺点是什么？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#说说this" class="sidebar-link">说说this</a></li></ul></li><li><a href="/interviewquestions/#es6篇" class="sidebar-link">ES6篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#var、let、const之间的区别-必问" class="sidebar-link">var、let、const之间的区别 (必问)</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#for-in-和for-of有什么区别？" class="sidebar-link">for...in 和for...of有什么区别？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#为啥大多数情况都使用箭头函数？" class="sidebar-link">为啥大多数情况都使用箭头函数？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#js-的提升是什么" class="sidebar-link">JS 的提升是什么</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#es6-中的临时死区是什么" class="sidebar-link">ES6 中的临时死区是什么</a></li></ul></li><li><a href="/interviewquestions/#http篇" class="sidebar-link">HTTP篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#http和https的区别-必考" class="sidebar-link">HTTP和HTTPS的区别(必考)</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#http的特性和状态码说一下" class="sidebar-link">HTTP的特性和状态码说一下</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#详细说一下-tcp-的三次握手" class="sidebar-link">详细说一下 TCP 的三次握手</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#怎么跨域？jsonp-是什么？cors-是什么？postmessage-是什么？" class="sidebar-link">怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#http请求方法有哪些？" class="sidebar-link">HTTP请求方法有哪些？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#get，post的区别？" class="sidebar-link">GET，POST的区别？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#tcp-跟-udp的区别？" class="sidebar-link">TCP 跟 UDP的区别？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#cache-control-和-etag-的区别是什么？" class="sidebar-link">Cache-Control 和 Etag 的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#cookie-是什么？session-是什么？" class="sidebar-link">Cookie 是什么？Session 是什么？</a></li></ul></li><li><a href="/interviewquestions/#vue篇" class="sidebar-link">VUE篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewquestions/#说一下vue的优点" class="sidebar-link">说一下Vue的优点</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#说一下vue的生命周期-必考" class="sidebar-link">说一下Vue的生命周期(必考)</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#什么是组件以及如何使用组件" class="sidebar-link">什么是组件以及如何使用组件</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#vue组件间是如何通信的-必考" class="sidebar-link">Vue组件间是如何通信的(必考)</a></li><li class="sidebar-sub-header"><a href="/interviewquestions/#vue是如何实现双向数据绑定的-vue双向数据绑定原理-重点" class="sidebar-link">Vue是如何实现双向数据绑定的(Vue双向数据绑定原理)(重点)</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="高频前端面试题-基础篇"><a href="#高频前端面试题-基础篇" class="header-anchor">#</a> 高频前端面试题-基础篇</h1> <h2 id="html篇"><a href="#html篇" class="header-anchor">#</a> HTML篇</h2> <h3 id="meta-viewport-是做什么用的"><a href="#meta-viewport-是做什么用的" class="header-anchor">#</a> meta viewport 是做什么用的?</h3> <p>将视口大小设置为可视区域的大小。</p> <p><strong>什么是视口</strong> <br>
视口简单理解就是可视区域大小。<br>
在PC端，视口大小就是浏览器窗口可视区域的大小 <br>
在移动端, 视口大小并不等于窗口大小, 移动端视口宽度被人为定义为了980 <br></p> <p><strong>如何保证在移动端不自动缩放网页的尺寸</strong> <br>
通过meta设置视口大小 <br></p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>viewport 是指 web 页面上用户的可视区域。
<br></p> <p>meta标签的属性:</p> <div class="language-text extra-class"><pre class="language-text"><code>width=device-width 设置视口宽度等于设备的宽度
initial-scale=1.0 初始缩放比例, 1不缩放
maximum-scale：允许用户缩放到的最大比例
minimum-scale：允许用户缩放到的最小比例
user-scalable：用户是否可以手动缩放
</code></pre></div><h3 id="content-type-有哪些？"><a href="#content-type-有哪些？" class="header-anchor">#</a> content-type 有哪些？</h3> <p>常见的媒体格式类型如下：</p> <ul><li>text/html ： HTML格式</li> <li>text/plain ：纯文本格式</li> <li>text/xml ： XML格式</li> <li>image/gif ：gif图片格式</li> <li>image/jpeg ：jpg图片格式</li> <li>image/png：png图片格式</li></ul> <h3 id="dom-的重绘-和-回流"><a href="#dom-的重绘-和-回流" class="header-anchor">#</a> DOM 的重绘 和 回流</h3> <p>回流必将引起重绘，重绘不一定会引起回流</p> <h4 id="回流-reflow"><a href="#回流-reflow" class="header-anchor">#</a> 回流 (Reflow)</h4> <p>当<strong>Render Tree </strong>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p> <p>会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除可见的DOM元素</li> <li>激活CSS伪类（例如：:hover）</li> <li>查询某些属性或调用某些方法</li></ul> <h4 id="重绘-repaint"><a href="#重绘-repaint" class="header-anchor">#</a> 重绘 (Repaint)</h4> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <p>现代浏览器会对频繁的回流或重绘操作进行优化：</p> <p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p> <h2 id="css篇"><a href="#css篇" class="header-anchor">#</a> CSS篇</h2> <h3 id="说说盒模型"><a href="#说说盒模型" class="header-anchor">#</a> 说说盒模型</h3> <p>盒模型的组成，由里向外content,padding,border,margin.<br>
在IE盒子模型中，width表示content+padding+border这三个部分的宽度<br>
在标准的盒子模型中，width指content部分的宽度</p> <div class="language-text extra-class"><pre class="language-text"><code>box-sizing：content-box;  width=内容区宽度
box-sizing：border-box;   width=内容区宽度+padding宽度+margin宽度
</code></pre></div><h3 id="如何解决外边距叠加的问题？"><a href="#如何解决外边距叠加的问题？" class="header-anchor">#</a> 如何解决外边距叠加的问题？</h3> <p>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。<br></p> <p>原因如果块元素的 margin-top 与它的第一个子元素的 margin-top 之间没有 border、padding、inline content、 clearance 来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有 border、padding、inline content、height、min-height、 max-height 分隔，那么外边距会塌陷。子元素多余的外边距会被父元素的外边距截断。</p> <ul><li>全部都为正值，发生边距重叠我们取得是最大值</li> <li>不全是正值，则都取绝对值，然后用正值的最大值减去绝对值的最大值</li> <li>没有正值，则都取绝对值，然后用0减去最大值</li> <li>假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起</li></ul> <h3 id="为什么padding-bottom-是基于父元素的宽度而不是父元素的高度计算的？"><a href="#为什么padding-bottom-是基于父元素的宽度而不是父元素的高度计算的？" class="header-anchor">#</a> 为什么padding-bottom 是基于父元素的宽度而不是父元素的高度计算的？</h3> <ul><li>margin/padding计算都基于一个值，width进行计算，这样能够保证top,right,bottom,left四个值的一致性</li> <li>由于父元素的高度是根据其所包含的子元素进行计算的，如果子元素的margin/padding是基于父元素高度计算的话，那么会引起高度计算的循环依赖。</li></ul> <h2 id="javascript篇"><a href="#javascript篇" class="header-anchor">#</a> JavaScript篇</h2> <h3 id="javascript是什么，它的优缺点是什么？"><a href="#javascript是什么，它的优缺点是什么？" class="header-anchor">#</a> JavaScript是什么，它的优缺点是什么？</h3> <p>JavaScript是一种基于对象（Object）和事件驱动（Event Driven）并具有相对安全性的客户端脚本语言。是基于浏览器内核为html添加生命力的脚本语言<br>
具有以下特点：<strong>动态，弱类型，单线程，内置支持类 </strong><br>
优点:</p> <ul><li>js减少网络传输</li> <li>js方便操纵html对象</li> <li>js支持分布式运算</li></ul> <p>缺点:</p> <ul><li>各个浏览器对js的支持程度不同</li> <li>web安全对js一些功能有限制，例如读写、保存数据等</li></ul> <h3 id="说说this"><a href="#说说this" class="header-anchor">#</a> 说说this</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> window<span class="token operator">/</span>global
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> obj
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> xx
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> xx
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> xx
<span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> 新的对象
<span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token parameter"><span class="token keyword">this</span></span> <span class="token operator">=&gt;</span> 外面的 <span class="token keyword">this</span>
</code></pre></div><h2 id="es6篇"><a href="#es6篇" class="header-anchor">#</a> ES6篇</h2> <h3 id="var、let、const之间的区别-必问"><a href="#var、let、const之间的区别-必问" class="header-anchor">#</a> var、let、const之间的区别 (必问)</h3> <div class="language-text extra-class"><pre class="language-text"><code>1.var声明变量可以重复声明，而let不可以重复声明
2.var是不受限于块级的，而let是受限于块级
3.var会与window相映射（会挂一个属性），而let不与window相映射
4.var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错
5.const声明之后必须赋值，否则会报错
6.const定义不可变的量，改变了就会报错
7.const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错
</code></pre></div><h3 id="for-in-和for-of有什么区别？"><a href="#for-in-和for-of有什么区别？" class="header-anchor">#</a> for...in 和for...of有什么区别？</h3> <p>ES6规定，有所部署了载了Iterator接口的对象<strong>(可遍历对象)</strong>都可以通过for...of去遍历，而for..in仅仅可以遍历对象。<br>
这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习。</p> <h3 id="为啥大多数情况都使用箭头函数？"><a href="#为啥大多数情况都使用箭头函数？" class="header-anchor">#</a> 为啥大多数情况都使用箭头函数？</h3> <ul><li>作用域安全性:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的thisObject。如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。</li> <li>紧凑性:箭头函数更容易读写。</li> <li>清晰度:使用箭头函数可明确知道当前 this 指向。</li></ul> <h3 id="js-的提升是什么"><a href="#js-的提升是什么" class="header-anchor">#</a> JS 的提升是什么</h3> <p>提升是指 JS 解释器将所有变量和函数声明移动到当前作用域顶部的操作，提升有两种类型</p> <ul><li>变量提升</li> <li>函数提升</li></ul> <p>只要一个<font color="red">var</font>(或函数声明)出现在一个作用域内，这个声明就被认为属于整个作用域，并且可以在任何地方访问。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正常运行, foo 已被提升</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">3</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>   <span class="token comment">// 3</span>
  <span class="token keyword">var</span> a                        
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span>   <span class="token comment">// 2</span>
</code></pre></div><h3 id="es6-中的临时死区是什么"><a href="#es6-中的临时死区是什么" class="header-anchor">#</a> ES6 中的临时死区是什么</h3> <p>在 ES6 中，let 和const 跟 var、class和function一样也会被提升，只是在进入作用域和被声明之间有一段时间不能访问它们，这段时间是临时死区(TDZ)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//console.log(aLet)  // would throw ReferenceError</span>
<span class="token keyword">let</span> aLet<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aLet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
aLet <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aLet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
</code></pre></div><h2 id="http篇"><a href="#http篇" class="header-anchor">#</a> HTTP篇</h2> <h3 id="http和https的区别-必考"><a href="#http和https的区别-必考" class="header-anchor">#</a> HTTP和HTTPS的区别(必考)</h3> <p>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头 <br>
HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密<br>
HTTP 的端口号是 80，HTTPS 是 443<br>
HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费<br>
HTTP 的连接很简单，是无状态的；<br>
HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p> <h3 id="http的特性和状态码说一下"><a href="#http的特性和状态码说一下" class="header-anchor">#</a> HTTP的特性和状态码说一下</h3> <div class="language-text extra-class"><pre class="language-text"><code>区分状态码
1××开头  - 信息提示
2××开头  - 请求成功
3××开头  - 请求被重定向
4××开头  - 请求错误
5××开头  - 服务器错误

常见状态码
200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

补充：301 和 302 的区别是什么？
301 永久重定向，浏览器会记住
302 临时重定向
</code></pre></div><h3 id="详细说一下-tcp-的三次握手"><a href="#详细说一下-tcp-的三次握手" class="header-anchor">#</a> 详细说一下 TCP 的三次握手</h3> <ol><li>第一次握手(SYN=1, seq=x):</li></ol> <blockquote><ol><li>客户端发送一个 TCP的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口(请求同步)，并选择序号 seq=x，表明传送数据时的第一个数据字节的序号是 x。(seq是个随机值)</li> <li>发送完毕后，客户端进入 SYN_SEND 状态。</li></ol></blockquote> <ol start="2"><li>第二次握手(SYN=1, ACK=1, seq=y, ack=x+1):</li></ol> <blockquote><ol><li>服务器的TCP收到连接请求报文段后，如同意，则发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号(随机值y)，放到seq 域里，同时将确认序号ack设置为客户的 ISN 加1，即 x+1(即回复对方确认收到了序列号为x开始的包，且希望下次的数据从x+1的位置开始)。</li> <li>发送完毕后，服务器端进入 SYN_RCVD 状态。</li></ol></blockquote> <ol start="3"><li>第三次握手(ACK=1，ack=y+1，seq=x+1)</li></ol> <blockquote><ol><li>客户端收到此报文段后再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段ack中发送给对方，并且告诉服务器自己的seq=x+1</li> <li>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP握手结束。</li></ol></blockquote> <h3 id="怎么跨域？jsonp-是什么？cors-是什么？postmessage-是什么？"><a href="#怎么跨域？jsonp-是什么？cors-是什么？postmessage-是什么？" class="header-anchor">#</a> 怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？</h3> <div class="language-html extra-class"><pre class="language-html"><code>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。
为来防止CSRF攻击
1.JSONP
    JSONP 的原理很简单，就是利用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> 标签没有跨域限制的漏洞。
    通过 <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span><span class="token operator">&gt;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    	<span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    JSONP 使用简单且兼容性不错，但是只限于 get 请求。
2.CORS
    CORS 需要浏览器和后端同时支持，需要设置 Access-Control-Allow-Origin:http://foo.example
    IE 8 和 9 需要通过 XDomainRequest 来实现。
3.postMessage
    这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
    
补充：
JSONP和AJAX相比的优缺点？
1.JSONP可以跨域 
2.因为JSONP是通过script标签发送的GET请求，所以读不到AJAX那么精确的状态码
</code></pre></div><h3 id="http请求方法有哪些？"><a href="#http请求方法有哪些？" class="header-anchor">#</a> HTTP请求方法有哪些？</h3> <h4 id="get"><a href="#get" class="header-anchor">#</a> GET</h4> <p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</p> <h4 id="head"><a href="#head" class="header-anchor">#</a> HEAD</h4> <p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p> <h4 id="post"><a href="#post" class="header-anchor">#</a> POST</h4> <p>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</p> <h4 id="put"><a href="#put" class="header-anchor">#</a> PUT</h4> <p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p> <h4 id="delete"><a href="#delete" class="header-anchor">#</a> DELETE</h4> <p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p> <h4 id="options"><a href="#options" class="header-anchor">#</a> OPTIONS</h4> <p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p> <h3 id="get，post的区别？"><a href="#get，post的区别？" class="header-anchor">#</a> GET，POST的区别？</h3> <ul><li>提交数据存储位置不同
GET请求会将数据放到URL后面POST请求会将数据放到请求体中</li> <li>对提交的数据大小限制不同
GET请求对所发信息量的限制是2000个字符POST请求对信息量没有限制</li> <li>对提交的数据编码不同
GET请求的参数只能是ASCII码，所以中文需要URL编码POST请求传参没有这个限制</li> <li>应用场景不同
GET请求用于提交非敏感数据和小数据POST请求用于提交敏感数据和大数据</li> <li>get请求可以被缓存，post不可以被缓存</li> <li>get后退不会有影响，post后退会重新进行提交</li> <li>get请求的记录会留在历史记录中，post请求不会留在历史记录</li></ul> <h3 id="tcp-跟-udp的区别？"><a href="#tcp-跟-udp的区别？" class="header-anchor">#</a> TCP 跟 UDP的区别？</h3> <p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。<br></p> <p>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</p> <p>区别：</p> <ol><li>基于连接与无连接；</li> <li>对系统资源的要求（TCP较多，UDP少）；</li> <li>UDP程序结构较简单；</li> <li>流模式与数据报模式 ；</li> <li>TCP保证数据正确性，UDP可能丢包；</li> <li>TCP保证数据顺序，UDP不保证。</li></ol> <h3 id="cache-control-和-etag-的区别是什么？"><a href="#cache-control-和-etag-的区别是什么？" class="header-anchor">#</a> Cache-Control 和 Etag 的区别是什么？</h3> <p>Cache-Control表示浏览器使用缓存，不向服务器发请求 <br></p> <p>ETag是会发请求的，只不过服务器根据请求的东西的内容有无变化来判断是否返回请求的资源</p> <h3 id="cookie-是什么？session-是什么？"><a href="#cookie-是什么？session-是什么？" class="header-anchor">#</a> Cookie 是什么？Session 是什么？</h3> <div class="language-text extra-class"><pre class="language-text"><code>1.Cookie:
    HTTP响应通过 Set-Cookie 设置 Cookie
    浏览器访问指定域名是必须带上 Cookie 作为 Request Header
    Cookie 一般用来记录用户信息

2.Session:
    Session 是服务器端的内存（数据）
    Session 一般通过在 Cookie 里记录 SessionID 实现
    SessionID 一般是随机数
</code></pre></div><h2 id="vue篇"><a href="#vue篇" class="header-anchor">#</a> VUE篇</h2> <h3 id="说一下vue的优点"><a href="#说一下vue的优点" class="header-anchor">#</a> 说一下Vue的优点</h3> <h4 id="_1-体积小"><a href="#_1-体积小" class="header-anchor">#</a> 1. 体积小</h4> <p>压缩后只有33K;</p> <h4 id="_2-更高的运行效率"><a href="#_2-更高的运行效率" class="header-anchor">#</a> 2. 更高的运行效率</h4> <p>基于虚拟DOM, 一种可以预选通过JavaScript进行各种计算, 把最终的DOM操作计算出来并优化的技术，由于这个DOM操作属于预处理操作， 并没有真正地操作DOM， 所以叫虚拟DOM。</p> <h4 id="_3-双向数据绑定"><a href="#_3-双向数据绑定" class="header-anchor">#</a> 3. 双向数据绑定</h4> <p>让开发者不用再去操作DOM对象, 把更多的精力投入到业务逻辑上。</p> <h4 id="_4-生态丰富、学习成本低"><a href="#_4-生态丰富、学习成本低" class="header-anchor">#</a> 4. 生态丰富、学习成本低</h4> <p>市场上拥有大量成熟、稳重的基于Vue.js的UI框架、常用组件！拿来即用实现快速开发！
对初学者友好、入门容易、学习资料多。</p> <h3 id="说一下vue的生命周期-必考"><a href="#说一下vue的生命周期-必考" class="header-anchor">#</a> 说一下Vue的生命周期(必考)</h3> <p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p> <p>Vue生命周期可以分为三个阶段：创建阶段、运行阶段、销毁阶段</p> <h4 id="创建阶段的生命周期方法"><a href="#创建阶段的生命周期方法" class="header-anchor">#</a> 创建阶段的生命周期方法</h4> <ol><li>beforeCreate
在调用beforeCreate的时候, 仅仅表示Vue实例刚刚被创建出来
此时此刻还没有初始化好Vue实例中的数据和方法, 所以还不能访问Vue实例中保存的数据和方法</li> <li>created
在调用created的时候, 是我们最早能够访问Vue实例中保存的数据和方法的地方</li> <li>beforeMount
在调用beforeMount的时候, 表示Vue已经编译好了最终模板, 但是还没有将最终的模板渲染到界面上</li> <li>mounted
在调用mounted的时候, 表示Vue已经完成了模板的渲染, 我们已经可以拿到界面上渲染之后的内容了</li></ol> <h4 id="运行阶段的生命周期方法"><a href="#运行阶段的生命周期方法" class="header-anchor">#</a> 运行阶段的生命周期方法</h4> <ol><li>beforeUpdate
在调用beforeUpdate的时候, 表示Vue实例中保存的数据被修改了
只有保存的数据被修改了才会调用beforeUpdate, 否则不会调用
在调用beforeUpdate的时候, 数据已经更新了, 但是界面还没有更新</li> <li>updated
在调用updated的时候, 表示Vue实例中保存的数据被修改了, 并且界面也同步了修改的数据了
也就是说: 数据和界面都同步更新之后就会调用updated</li></ol> <h4 id="销毁阶段的生命周期方法"><a href="#销毁阶段的生命周期方法" class="header-anchor">#</a> 销毁阶段的生命周期方法</h4> <ol><li>beforeDestroy
在调用beforeDestroy的时候, 表示当前组件即将被销毁了
只要组件不被销毁, 那么beforeDestroy就不会调用。beforeDestroy函数是我们最后能够访问到组件数据和方法的函数</li> <li>destroyed
在调用destroyed的时候, 表示当前组件已经被销毁了
只要组件不被销毁, 那么destroyed就不会调用。在这个生命周期方法中无法再去操作组件中数据和方法</li></ol> <h3 id="什么是组件以及如何使用组件"><a href="#什么是组件以及如何使用组件" class="header-anchor">#</a> 什么是组件以及如何使用组件</h3> <p>组件就是把一个很大的界面拆分为多个小的界面, 每一个小的界面就是一个组件
将大界面拆分成小界面就是组件化</p> <p>组件化的好处是可以简化Vue实例的代码，可以提高代码复用性
Vue的组件注册分为全局注册和局部注册</p> <p>全局注册是在全局Vue对象的component属性中绑定定义好的模板<br>
局部注册是在Vue实例的components属性中绑定定义好的模板<br></p> <p>如果是.vue文件的组件则需要通过import导入到需要的组件中。</p> <h3 id="vue组件间是如何通信的-必考"><a href="#vue组件间是如何通信的-必考" class="header-anchor">#</a> Vue组件间是如何通信的(必考)</h3> <p>方法一、<strong>props/ $emit </strong></p> <p>在父组件中通过v-bind传递数据，在子组件中通过props接收数据
在父组件中通过 v-on 传递方法，在子组件的自定义方法中通过 this.$emit('自定义接收名称'); 触发传递过来的方法</p> <p>方法二、<strong> $emit/ $on </strong></p> <p>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。</p> <p>方法三、<strong>vuex</strong></p> <p>vuex 是 Vue 配套的 公共数据管理工具，我们可以将共享的数据保存到 vuex 中， 方便整个程序中的任何组件都可以获取和修改vuex中保存的公共数据</p> <ul><li>创建Vuex对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 这里的state就相当于组件中的data, 就是专门用于保存共享数据的</span>
    state<span class="token operator">:</span> <span class="token punctuation">{</span>
        msg<span class="token operator">:</span> <span class="token string">&quot;共享数据&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>在祖先组件中添加 store 的 key 保存Vuex对象</li></ul> <p>只要祖先组件中保存了Vuex对象 , 那么祖先组件和所有的后代组件就可以使用Vuex中保存的共享数据了</p> <div class="language-js extra-class"><pre class="language-js"><code>store<span class="token operator">:</span> store<span class="token punctuation">,</span>
</code></pre></div><ul><li>在使用Vuex中保存的共享数据的时候, 必须通过如下的格式来使用</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{this.$store.state.msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>方法四：作用域插槽</p> <p>作用域插槽就是带数据的插槽, 就是让父组件在填充子组件插槽内容时也能使用子组件的数据
应用场景在于: 子组件提供数据, 父组件决定如何渲染</p> <ul><li>在slot中通过 v-bind:数据名称=&quot;数据名称&quot; 方式暴露数据</li> <li>在父组件中通过 <code>&lt;template slot-scope=&quot;作用域名称&quot;&gt;</code>接收数据</li> <li>在父组件的 <code>&lt;template&gt;&lt;/template&gt;</code> 中通过 作用域名称.数据名称 方式使用数据</li></ul> <p>也就是说我们可以通过v-slot指令告诉Vue如何接收作用域插槽暴露的数据</p> <p>格式： v-slot:插槽名称=&quot;作用域名称&quot;<br>
简写: #插槽名称=&quot;作用域名称&quot;</p> <h3 id="vue是如何实现双向数据绑定的-vue双向数据绑定原理-重点"><a href="#vue是如何实现双向数据绑定的-vue双向数据绑定原理-重点" class="header-anchor">#</a> Vue是如何实现双向数据绑定的(Vue双向数据绑定原理)(重点)</h3> <div class="language-text extra-class"><pre class="language-text"><code>Vue数据双向绑定是指：数据变化更新视图，视图变化更新数据，例如输入框输入内容变化时，data中的数据同步变化；data中的数据变化时，文本节点的内容同步变化

Vue主要通过以下4个步骤实现数据双向绑定:

1.实现一个监听器「Observer」：
    对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()在属性上都加上getter和setter，这样后，给对象的某个值赋值，就会触发setter，那么就能监听到数据变化
2.实现一个解析器「Compile」：
    解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新
3.实现一个订阅者「Watcher」：
    Watcher订阅者是Observer和Compile之间通信的桥梁，主要任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息时，触发解析器Compile中对应的更新函数
4.实现一个订阅器「Dep」：
    订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b1624e8e.js" defer></script><script src="/assets/js/2.12e8692c.js" defer></script><script src="/assets/js/30.ff71561f.js" defer></script>
  </body>
</html>
