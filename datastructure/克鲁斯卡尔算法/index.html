<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>克鲁斯卡尔(Kruskal)算法 | Cary</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="专注于记录一些从开始到入门踩过的坑">
    <link rel="preload" href="/assets/css/0.styles.b8e99327.css" as="style"><link rel="preload" href="/assets/js/app.b1624e8e.js" as="script"><link rel="preload" href="/assets/js/2.12e8692c.js" as="script"><link rel="preload" href="/assets/js/21.1b6d07c1.js" as="script"><link rel="prefetch" href="/assets/js/10.eff93b86.js"><link rel="prefetch" href="/assets/js/11.793fbf77.js"><link rel="prefetch" href="/assets/js/12.4a71ec38.js"><link rel="prefetch" href="/assets/js/13.093a470d.js"><link rel="prefetch" href="/assets/js/14.c529c00a.js"><link rel="prefetch" href="/assets/js/15.9cc56e10.js"><link rel="prefetch" href="/assets/js/16.f161731c.js"><link rel="prefetch" href="/assets/js/17.438c44df.js"><link rel="prefetch" href="/assets/js/18.c02afc3a.js"><link rel="prefetch" href="/assets/js/19.c4b19fba.js"><link rel="prefetch" href="/assets/js/20.dec86c76.js"><link rel="prefetch" href="/assets/js/22.44c5118e.js"><link rel="prefetch" href="/assets/js/23.4da8ff8e.js"><link rel="prefetch" href="/assets/js/24.fdc9730d.js"><link rel="prefetch" href="/assets/js/25.806070ea.js"><link rel="prefetch" href="/assets/js/26.d8d44464.js"><link rel="prefetch" href="/assets/js/27.03a5f16f.js"><link rel="prefetch" href="/assets/js/28.e9711547.js"><link rel="prefetch" href="/assets/js/29.c20512e0.js"><link rel="prefetch" href="/assets/js/3.964ad172.js"><link rel="prefetch" href="/assets/js/30.ff71561f.js"><link rel="prefetch" href="/assets/js/31.44701f47.js"><link rel="prefetch" href="/assets/js/32.060499f3.js"><link rel="prefetch" href="/assets/js/33.c8f8e25c.js"><link rel="prefetch" href="/assets/js/34.484e7f5b.js"><link rel="prefetch" href="/assets/js/35.d0e86e52.js"><link rel="prefetch" href="/assets/js/36.6e9c597a.js"><link rel="prefetch" href="/assets/js/37.d0ea72cc.js"><link rel="prefetch" href="/assets/js/38.635da6e1.js"><link rel="prefetch" href="/assets/js/39.c6c12926.js"><link rel="prefetch" href="/assets/js/4.9e3305df.js"><link rel="prefetch" href="/assets/js/40.77988a3a.js"><link rel="prefetch" href="/assets/js/41.09ced7b0.js"><link rel="prefetch" href="/assets/js/42.f0c83ede.js"><link rel="prefetch" href="/assets/js/43.8433eb78.js"><link rel="prefetch" href="/assets/js/44.9a1d5c63.js"><link rel="prefetch" href="/assets/js/45.cb79a166.js"><link rel="prefetch" href="/assets/js/5.536117a3.js"><link rel="prefetch" href="/assets/js/6.fdeca71c.js"><link rel="prefetch" href="/assets/js/7.b91670df.js"><link rel="prefetch" href="/assets/js/8.53ae3032.js"><link rel="prefetch" href="/assets/js/9.2475cef8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8e99327.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Cary</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>克鲁斯卡尔(Kruskal)算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/datastructure/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/#克鲁斯卡尔代码讲解" class="sidebar-link">克鲁斯卡尔代码讲解</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="克鲁斯卡尔-kruskal-算法"><a href="#克鲁斯卡尔-kruskal-算法" class="header-anchor">#</a> 克鲁斯卡尔(Kruskal)算法</h1> <p>转载自：https://bbs.huaweicloud.com/blogs/139626</p> <p><em>总结每一步更新矩阵的值，以及最重要的是不能产生环形树</em> <br></p> <h2 id="克鲁斯卡尔代码讲解"><a href="#克鲁斯卡尔代码讲解" class="header-anchor">#</a> 克鲁斯卡尔代码讲解</h2> <p><img src="https://raw.githubusercontent.com/Cooohooo/cary-notebook-image/master/images/k1.png" alt="k1"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/**
 * 查找连线顶点的尾部下标
 */</span>
<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> parent<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>f<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        f <span class="token operator">=</span> parent<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>

    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    Edge edges<span class="token punctuation">[</span>MAXEDGE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义边集数组</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义一维数组来判断边与边是否形成回路</span>

    <span class="token comment">//构建边集数组并排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> INIFINTY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>begin <span class="token operator">=</span> i<span class="token punctuation">;</span>
                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">=</span> j<span class="token punctuation">;</span>
                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;打印最小生成树:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numEdges<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parent<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;(%d, %d) %d\n&quot;</span><span class="token punctuation">,</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>begin<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end
                   <span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    MGraph G<span class="token punctuation">;</span>
    <span class="token function">CreateMGraph</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>首先 我们声明一个数组 parent，并将它的值都初始化为 0</p></li> <li><p>我们调用函数 Find，传入的参数是数组 parent 和当前权值最小边（v4, v7）的 begin：4，因为 parent 中全部是 0 所以传出值使 n = 4</p></li> <li><p>同样的做法，传入（v4, v7）的 end：7，传出值使得 m = 7</p></li> <li><p>显然 n 与 m 不相等，因此 parent[4] = 7，此时 parent 数组为{ 0, 0, 0, 0, 7, 0, 0, 0, 0 } 此时我们已经将边（v4, v7）纳入最小生成树中</p></li> <li><p>重复循环，此时 i = 1，edge[1]得到边（v2, v8），n = 2，m = 8，parent[2] = 8，此时 parent 数组值为{ 0, 0, 8, 0, 7, 0, 0, 0, 0 }，这也表示边（v4, v7）和边（v2, v8）已经纳入到最小生成树</p></li> <li><p>重复循环，此时 i = 2，edge[2]得到边（v0, v1），n = 0，m = 1，parent[0] = 1，此时 parent 数组值为{ 1, 0, 8, 0, 7, 0, 0, 0, 0 }，这也表示边（v4, v7）和边（v2, v8）和（v0, v1） 已经纳入到最小生成树</p></li> <li><p>当 i = 3，4，5，6 时，分别将边（v0, v5），（v1, v8）,（v3, v7）,（v1, v6）纳入到最小生成树中，此时 parent 数组值为{ 1, 5, 8, 7, 7, 8, 0, 0, 6 }</p></li> <li><p>parent[0] = 1，表示 v0 和 v1 已经在生成树的边集合 A 中，parent[5] = 8，表示 v5 和 v8 在边集合 A 中，parent[8] = 6，表示 v8 和 v6 在边集合 A 中，parent[6] = 0，表示集合 A 暂时到头，同理，parent[2] = 8，表示 v2 和 v8 在一个集合中，再由 parent[3] = 7，parent[4] = 7，和 parent[7] = 0，可知 v3,v4,v7 在另一个边集合 B 中</p></li> <li><p>接下来 我们将判断如何防止生成树形成环路，当 i = 7，调用 Find 函数，传入参数 edges[7].begin = 5，此时 parent[5] = 8 &gt; 0，所以 f = 8，需要再次循环来得到生成树的根节点，parent[8] = 6，再次循环，parent[6] = 0，所以 Find 返回后第 10 行得到 n = 6，接着执行 m = Find(parent, edges[i].end); 传入参数 edges[7].end = 6，得到 m = 6，此时 n = m，不在打印，继续下一循环，这就告诉了我们边（v5, v6）是边集合 A 形成了环路不能讲其纳入最小生成树种</p></li> <li><p>与上面相同，（v1, v2）使得边集合 A 形成了环路，也不能将其纳入最小生成树中</p></li> <li><p>当 i = 9，边（v6, v7）得到 n = 6，m = 7，因此 parent[6] = 7，此时 parent 数组的值为{ 1, 5, 8, 7, 7, 8, 7, 0, 6 }
<br></p></li></ul> <p><strong>解释一下为什么，当 edge[3] 得到（v0, v5）时，不更新 parent[0] 的数值</strong></p> <p><img src="https://raw.githubusercontent.com/Cooohooo/cary-notebook-image/master/images/k2.png" alt="k2"></p> <p>edges[3],查询 0，5，此时 V0 的父是 V1，V1 对应的 parent[1]中存储的 0 表示 V1 是这棵树的父，parent[5]=0，即 V0 和 V5 不是同一棵树，可以连线。将 parent[1]置为 5，生成树变成下图：</p> <p><img src="https://raw.githubusercontent.com/Cooohooo/cary-notebook-image/master/images/k3.png" alt="k3"></p> <p>edges[4], 查询 1，8，不在同一棵树，此时 1 所在树的根是 5，将 1 和 8 连线，此时树合并应该将根节点 5 的 parent[5]置为 8.现在上图的两个棵树合并了</p> <p><img src="https://raw.githubusercontent.com/Cooohooo/cary-notebook-image/master/images/k4.png" alt="k4"></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b1624e8e.js" defer></script><script src="/assets/js/2.12e8692c.js" defer></script><script src="/assets/js/21.1b6d07c1.js" defer></script>
  </body>
</html>
