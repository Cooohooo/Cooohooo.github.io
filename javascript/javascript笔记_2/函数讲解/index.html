<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数 | Cary</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="专注于记录一些从开始到入门踩过的坑">
    <link rel="preload" href="/assets/css/0.styles.b8e99327.css" as="style"><link rel="preload" href="/assets/js/app.b1624e8e.js" as="script"><link rel="preload" href="/assets/js/2.12e8692c.js" as="script"><link rel="preload" href="/assets/js/37.d0ea72cc.js" as="script"><link rel="prefetch" href="/assets/js/10.eff93b86.js"><link rel="prefetch" href="/assets/js/11.793fbf77.js"><link rel="prefetch" href="/assets/js/12.4a71ec38.js"><link rel="prefetch" href="/assets/js/13.093a470d.js"><link rel="prefetch" href="/assets/js/14.c529c00a.js"><link rel="prefetch" href="/assets/js/15.9cc56e10.js"><link rel="prefetch" href="/assets/js/16.f161731c.js"><link rel="prefetch" href="/assets/js/17.438c44df.js"><link rel="prefetch" href="/assets/js/18.c02afc3a.js"><link rel="prefetch" href="/assets/js/19.c4b19fba.js"><link rel="prefetch" href="/assets/js/20.dec86c76.js"><link rel="prefetch" href="/assets/js/21.1b6d07c1.js"><link rel="prefetch" href="/assets/js/22.44c5118e.js"><link rel="prefetch" href="/assets/js/23.4da8ff8e.js"><link rel="prefetch" href="/assets/js/24.fdc9730d.js"><link rel="prefetch" href="/assets/js/25.806070ea.js"><link rel="prefetch" href="/assets/js/26.d8d44464.js"><link rel="prefetch" href="/assets/js/27.03a5f16f.js"><link rel="prefetch" href="/assets/js/28.e9711547.js"><link rel="prefetch" href="/assets/js/29.c20512e0.js"><link rel="prefetch" href="/assets/js/3.964ad172.js"><link rel="prefetch" href="/assets/js/30.ff71561f.js"><link rel="prefetch" href="/assets/js/31.44701f47.js"><link rel="prefetch" href="/assets/js/32.060499f3.js"><link rel="prefetch" href="/assets/js/33.c8f8e25c.js"><link rel="prefetch" href="/assets/js/34.484e7f5b.js"><link rel="prefetch" href="/assets/js/35.d0e86e52.js"><link rel="prefetch" href="/assets/js/36.6e9c597a.js"><link rel="prefetch" href="/assets/js/38.635da6e1.js"><link rel="prefetch" href="/assets/js/39.c6c12926.js"><link rel="prefetch" href="/assets/js/4.9e3305df.js"><link rel="prefetch" href="/assets/js/40.77988a3a.js"><link rel="prefetch" href="/assets/js/41.09ced7b0.js"><link rel="prefetch" href="/assets/js/42.f0c83ede.js"><link rel="prefetch" href="/assets/js/43.8433eb78.js"><link rel="prefetch" href="/assets/js/44.9a1d5c63.js"><link rel="prefetch" href="/assets/js/45.cb79a166.js"><link rel="prefetch" href="/assets/js/5.536117a3.js"><link rel="prefetch" href="/assets/js/6.fdeca71c.js"><link rel="prefetch" href="/assets/js/7.b91670df.js"><link rel="prefetch" href="/assets/js/8.53ae3032.js"><link rel="prefetch" href="/assets/js/9.2475cef8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8e99327.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Cary</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  目录
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>函数</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javascript/javascript%E7%AC%94%E8%AE%B0_2/%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/#函数声明：" class="sidebar-link">函数声明：</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/javascript/javascript%E7%AC%94%E8%AE%B0_2/%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/#函数表达式" class="sidebar-link">函数表达式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/javascript/javascript%E7%AC%94%E8%AE%B0_2/%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/#调用函数" class="sidebar-link">调用函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/javascript/javascript%E7%AC%94%E8%AE%B0_2/%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/#构造函数调用模式-问题来了-什么是执行上下文呢？？？" class="sidebar-link">构造函数调用模式 问题来了 什么是执行上下文呢？？？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/javascript/javascript%E7%AC%94%E8%AE%B0_2/%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/#函数作用域" class="sidebar-link">函数作用域</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h1> <h2 id="函数声明："><a href="#函数声明：" class="header-anchor">#</a> 函数声明：</h2> <p>一个函数定义（也称为函数声明，或函数语句）由一系列的 function 关键字组成，依次为：</p> <ul><li>函数的名称。</li> <li>函数参数列表，包围在括号中并由逗号分隔。</li> <li>定义函数的 JavaScript 语句，用大括号{}括起来。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> number <span class="token operator">*</span> number
<span class="token punctuation">}</span>
</code></pre></div><p>原始参数（比如一个具体的数字）被作为值(number)传递给函数；值(number)被传递给函数，如果被调用函数改变了这个参数的值，这样的改变不会影响到全局或调用函数。</p> <p>如果你传递一个对象（即一个非原始值，例如 Array 或用户自定义的对象）作为参数，而函数改变了这个对象的属性，这样的改变对函数外部是可见的，如下面的例子所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token parameter">theObject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    theObject<span class="token punctuation">.</span>make <span class="token operator">=</span> <span class="token string">'Toyota'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> mycar <span class="token operator">=</span> <span class="token punctuation">{</span> make<span class="token operator">:</span> <span class="token string">'Honda'</span><span class="token punctuation">,</span> model<span class="token operator">:</span> <span class="token string">'Accord'</span><span class="token punctuation">,</span> year<span class="token operator">:</span> <span class="token number">1998</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> x<span class="token punctuation">,</span> y
x <span class="token operator">=</span> mycar<span class="token punctuation">.</span>make <span class="token comment">// x获取的值为 &quot;Honda&quot;</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span>mycar<span class="token punctuation">)</span>
y <span class="token operator">=</span> mycar<span class="token punctuation">.</span>make <span class="token comment">// y获取的值为 &quot;Toyota&quot;</span>
<span class="token comment">// (make属性被函数改变了)</span>
</code></pre></div><h2 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h2> <p>虽然上面的函数声明在语法上是一个语句，但函数也可以由函数表达式创建。这样的函数可以是匿名的；它不必有一个名称。例如，函数 square 也可这样来定义：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> number <span class="token operator">*</span> number
<span class="token punctuation">}</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// x gets the value 16</span>
</code></pre></div><p>然而，函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> n <span class="token operator">*</span> <span class="token function">fac</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>当将函数作为参数传递给另一个函数时，函数表达式很方便。下面的例子演示了一个叫 map 的函数如何被定义，而后使用<font color="red">一个表达式函数作为其第一个参数进行调用</font>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        i <span class="token comment">//创建一个新数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x
<span class="token punctuation">}</span>
<span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> cube <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> numbers<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cube<span class="token punctuation">)</span>
</code></pre></div><h2 id="调用函数"><a href="#调用函数" class="header-anchor">#</a> 调用函数</h2> <p>定义一个函数并不会自动的执行它。定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。调用函数才会以给定的参数真正执行这些动作。例如，一旦你定义了函数 square，你可以如下这样调用它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
</code></pre></div><ol><li>函数调用模式：</li></ol> <p><font color="red">当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。</font>对于普通的函数调用来说，函数的返回值就是调用表达式的值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token comment">//7</span>
</code></pre></div><ol start="2"><li>方法调用模式：</li></ol> <p><font color="red">当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this 被绑定到该对象</font> 如果调用表达式包含一个提取属性的动作，那么它就是被当做一个方法来调用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">m</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
o<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//1</span>
</code></pre></div><p>和变量不同，关键字 this 没有作用域的限制，嵌套的函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套函数作为函数调用，其 this 值不是 Windows(非严格模式下)就是 undefined(严格模式下)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">m</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">function</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//window</span>
</code></pre></div><p>如果想访问这个外部函数的 this 值，需要将 this 的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量 self 或 that 来保存 this</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">m</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> o<span class="token punctuation">)</span> <span class="token comment">//true</span>
        <span class="token keyword">function</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> o<span class="token punctuation">)</span> <span class="token comment">//false</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self <span class="token operator">===</span> o<span class="token punctuation">)</span> <span class="token comment">//true</span>
            <span class="token keyword">return</span> self
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 函数调用的地方</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> o<span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><p>可以看到第一个 this 指代的是 var o 这个对象，因为嵌套函数不能从调用它的函数中继承 this，return n() 是调用内部函数的地方，而且内部函数是通过函数调用的，所以我们能看到 console.log(this === o); // <font color="red">false</font>，因为内部函数的 this 指代的是 Windows 对象，而 console.log(self === o); // <font color="red">true</font>，是因为我们把 var o 的 this 传给了 self 变量</p> <ol start="3"><li>构造函数调用模式：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//这是一个构造函数</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">//1</span>
</code></pre></div><p>如果构造函数没有形参，javascript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//等价于</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为<font color="red">调用上下文</font>(上下文具体看后面的解释，非常重要的定义)。也就是说，在表达式 new o.m()中，<font color="red">调用上下文并不是 o</font></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">m</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">o<span class="token punctuation">.</span>m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> obj <span class="token operator">===</span> o<span class="token punctuation">)</span> <span class="token comment">//{} false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> o<span class="token punctuation">.</span>m<span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><p>构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">//{a:2}</span>
</code></pre></div><p>如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">//{a:1}</span>
</code></pre></div><ol start="4"><li>间接调用模式：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//3</span>
</code></pre></div><p>javascript 中函数也是对象，函数对象也可以包含方法。call()和 apply()方法可以用来间接地调用函数<br></p> <p>这两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call()方法使用它自有的实参列表作为函数的实参，apply()方法则要求以数组的形式传入参数<br></p> <h2 id="构造函数调用模式-问题来了-什么是执行上下文呢？？？"><a href="#构造函数调用模式-问题来了-什么是执行上下文呢？？？" class="header-anchor">#</a> 构造函数调用模式 问题来了 什么是执行上下文呢？？？</h2> <p>Q: 什么是执行上下文？</p> <blockquote><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p></blockquote> <p>Q: 执行上下文的类型</p> <blockquote><p>JavaScript 中有三种执行上下文类型。</p> <ul><li>全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li> <li>函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li> <li>Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li></ul></blockquote> <p>Q: 执行栈</p> <blockquote><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。<br>
当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个<font color="red">函数调用！！！！！确定要是函数调用的时候</font>，它会为该函数创建一个新的执行上下文并压入栈的顶部。<br>
引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'Hello World!'</span>

<span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside first function'</span><span class="token punctuation">)</span>
    <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Again inside first function'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside second function'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside Global Execution Context'</span><span class="token punctuation">)</span>
</code></pre></div><br> <p><img src="https://raw.githubusercontent.com/Cooohooo/cary-notebook-image/master/images/%E6%89%A7%E8%A1%8C%E6%A0%88.png" alt="执行栈"></p> <p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <font color="red">first()</font> 函数<font color="red">调用</font>时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。<br></p> <p>当从 <font color="red">first()</font> 函数内部<font color="red">调用 second() </font>函数时，JavaScript 引擎为 <font color="red">second()</font> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <font color="red">second()</font> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <font color="red">first()</font> 函数的执行上下文。<br></p> <p>当 <font color="red">first() </font>执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。 <br></p> <p>Q: 怎么创建执行上下文？</p> <blockquote><p>到现在，我们已经看过 JavaScript 怎样管理执行上下文了，现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。<br></p> <p>创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段
创建阶段：
在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p> <ul><li>this 值的决定，即我们所熟知的 This 绑定。</li> <li>创建词法环境组件(英文：LexicalEnvironment)</li> <li>创建变量环境组件(英文：VariableEnvironment)</li></ul></blockquote> <p>词法环境 <br>
官方的 ES6 文档把词法环境定义为</p> <div class="language-js extra-class"><pre class="language-js"><code>词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。
</code></pre></div><p>现在，在词法环境的内部有两个组件：(1) 环境记录器和 (2) 一个外部环境的引用。<br></p> <div class="language- extra-class"><pre><code>1. 环境记录器(EnvironmentRecord)是存储变量和函数声明的实际位置。
2. 外部环境的引用(outer)意味着它可以访问其父级词法环境（作用域）。
</code></pre></div><p>词法环境有两种类型：</p> <ul><li>全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <font color="red">this</font>的值指向全局对象。</li> <li>在函数环境中，函数内部用户定义的变量存储在环境记录器(EnvironmentRecord)中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul> <p>环境记录器也有两种类型：</p> <ul><li>声明式环境记录器存储变量、函数和参数。</li> <li>对象环境记录器用来定义出现在全局上下文中的变量和函数的关系。</li></ul> <p>简而言之，</p> <ul><li>在全局环境中，环境记录器是对象环境记录器。</li> <li>在函数环境中，环境记录器是声明式环境记录器。</li></ul> <p>注意 — 对于函数环境，声明式环境记录器还包含了一个传递给函数的 <font color="red">arguments</font> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length（会在下面的例子中看到具体的用法）<br></p> <p>变量环境：<br></p> <p>它同样是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。<br>
如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。<br>
在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，<font color="red">而后者只用来存储 var 变量绑定</font>
举个栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">30</span>
<span class="token keyword">var</span> c

<span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">,</span> f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token number">20</span>
    <span class="token keyword">return</span> e <span class="token operator">*</span> f <span class="token operator">*</span> g
<span class="token punctuation">}</span>

c <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>
</code></pre></div><p>执行上下文看起来像这样</p> <div class="language-js extra-class"><pre class="language-js"><code>GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>

  ThisBinding<span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>

  LexicalEnvironment<span class="token operator">:</span> <span class="token punctuation">{</span>
    EnvironmentRecord<span class="token operator">:</span> <span class="token punctuation">{</span>
      Type<span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>
      <span class="token comment">// 在这里绑定标识符</span>
      a<span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>
      b<span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>
      multiply<span class="token operator">:</span> <span class="token operator">&lt;</span> func <span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
    outer<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  VariableEnvironment<span class="token operator">:</span> <span class="token punctuation">{</span>
    EnvironmentRecord<span class="token operator">:</span> <span class="token punctuation">{</span>
      Type<span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>
      <span class="token comment">// 在这里绑定标识符</span>
      c<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    outer<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  ThisBinding<span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>

  LexicalEnvironment<span class="token operator">:</span> <span class="token punctuation">{</span>
    EnvironmentRecord<span class="token operator">:</span> <span class="token punctuation">{</span>
      Type<span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>
      <span class="token comment">// 在这里绑定标识符</span>
      Arguments<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> length<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    outer<span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

VariableEnvironment<span class="token operator">:</span> <span class="token punctuation">{</span>
    EnvironmentRecord<span class="token operator">:</span> <span class="token punctuation">{</span>
      Type<span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>
      <span class="token comment">// 在这里绑定标识符</span>
      g<span class="token operator">:</span> <span class="token keyword">undefined</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    outer<span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意 — 只有遇到调用函数 <font color="red">multiply </font>时，函数执行上下文才会被创建。<br>
可能你已经注意到 let 和 <font color="red">const</font> 定义的变量并没有关联任何值，但 <font color="red">var</font> 定义的变量被设成了 <font color="red">undefined</font><br>
这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <font color="red">undefined</font> 情况下），或者未初始化（ <font color="red">let</font> 和 <font color="red">const</font> 情况下）<br>
这就是为什么你可以在声明之前访问 <font color="red">var</font> 定义的变量（虽然是 <font color="red">undefined</font>），但是在声明之前访问 <font color="red">let</font> 和 <font color="red">const</font> 的变量会得到一个引用错误。 <br>
这就是我们说的<font color="red">变量声明提升</font>。</p> <h2 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h2> <p>在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。换言之，定义在全局域中的函数可以访问所有定义在全局域中的变量。<font color="red">在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量。</font></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 下面的变量定义在全局作用域(global scope)中</span>
<span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span>
    num2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    name <span class="token operator">=</span> <span class="token string">'Chamahk'</span>
<span class="token comment">// 本函数定义在全局作用域</span>
<span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">*</span> num2
<span class="token punctuation">}</span>
<span class="token function">multiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回 60</span>
<span class="token comment">// 嵌套函数的例子</span>
<span class="token keyword">function</span> <span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//可以访问父函数中有权访问的任何其他变量</span>
    <span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
        num2 <span class="token operator">=</span> <span class="token number">3</span>
    <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name <span class="token operator">+</span> <span class="token string">' scored '</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回 &quot;Chamahk scored 5&quot;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b1624e8e.js" defer></script><script src="/assets/js/2.12e8692c.js" defer></script><script src="/assets/js/37.d0ea72cc.js" defer></script>
  </body>
</html>
